set shell zsh
set drawbox true
set icons true
set ignorecase true
set shellopts '-euy'
set ifs "\n"
set preview true
set hidden true
set mouse true
set number true
set relativenumber true
set tabstop 4

# space @ top & bottom
set scrolloff 10

# Use the `dim` attribute instead of underline for the cursor in the preview pane
set cursorpreviewfmt "\033[7;2m"

# --------MAPPINGS--------

# unbind
map c
map m
map n
map e
map n
map f
map u
map R
map "'"
map '"'
map <enter>

map <c-<enter> cd-into
map <!> shell

map zp toggle-preview

map o open
map E open
map ee $$EDITOR "$f"
map u $view "$f"

map sl select "$f"

map p paste
map x cut
map y copy
map D delete
map <delete> delete

map r rename
map e rename-name
map R bmv

map L bottom
map R reload
map C clear
map U unselect
map J :updir; set dironly true; down; set dironly false; open
map K :updir; set dironly true; up; set dironly false; open

map <a-k> half-up
map <a-j> half-down
map <a-f> scroll-up
map <a-h> scroll-down

map F fzf_jump
map f fzf_search

# map C open_config

# trash
# map d trash
map tc clear_trash
map tr restore_trash

map ss stripspace

map af mkfile
map mr sudomkfile
map ad mkdir
map ms $mkscript
map ch chmod

# execute current file (must be executable)
map <x> $$f
map <X> !$f

# Archive
map az zip
map at tar
map ag targz
map ab targz
map au unarchive

# -------FUNCTIONS--------

cmd cd-into %{{
    # set lfcd to $fs
    # exit and cd into $lfcd
}}

# dynamically set number of columns
${{
    w=$(tput cols)
    if [ $w -le 80 ]; then
        lf -remote "send $id set ratios 1:2"
    elif [ $w -le 160 ]; then
        lf -remote "send $id set ratios 1:2:3"
    else
        lf -remote "send $id set ratios 1:2:3:5"
    fi
}}

cmd toggle-preview %{{
    if [ "$lf_preview" = "true" ]; then
        lf -remote "send $id :set preview false; set ratios 1:5"
    else
        lf -remote "send $id :set preview true; set ratios 1:2:3"
    fi
}}

cmd open ${{
    case $(file --mime-type -Lb $f) in
        text/markdown|x-markdown) glow "$f";;
        text/*|application/json) $EDITOR "$f";;
        *) xdg-open "$f" ;;
    esac
}}

cmd mkdir ${{
    printf "Directory Name: "
    read ans
    mkdir $ans
}}

cmd mkfile ${{
    printf "File Name: "
    read ans
    touch $ans
}}

cmd chmod ${{
    printf "Mode Bits: "
    read ans

    for file in "$fx" do
        chmod $ans $file
    done

    lf -remote 'send reload'
}}

cmd sudomkfile ${{
    printf "File Name: "
    read ans
    sudo touch $ans
}}

# filename
cmd rename ${{
    filename="${f##*/}"
    filename="$(printf '%q' "$filename")"
    filename="${filename// /<space>}"
    lf -remote "send $id push :rename<space>$filename"
}}

# filename w/o extension
cmd rename-name ${{
    filename="${f##*/}"
    filename="$(printf '%q' "$filename")"
    filename="${filename// /<space>}"
    lf -remote "send $id push :rename<space>$filename<a-b><c-b>"
}}

# bulk rename
cmd bmv ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi

    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"

    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit

    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

cmd delete ${{
    set -f
    printf "$fx\n"
    printf "delete?[y/n]"
    read ans
    [ "$ans" = "y" ] && rm -rf $fx
}}

cmd trash ${{
    files=$(printf "$fx" | tr '\n' ';')
    while [ "$files" ]; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "$file")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
    done
}}

cmd clear_trash %trash-empty

cmd restore_trash ${{
  trash-restore
}}

cmd stripspace %stripspace "$f"

cmd fzf_jump ${{
    res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location')"
    if [ -f "$res" ]; then
        cmd="select"
    elif [ -d "$res" ]; then
        cmd="cd"
    fi
    lf -remote "send $id $cmd \"$res\""
}}

cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

cmd open_config  ${{
  $EDITOR $(bookmenu -b ~/.config/bookmenu/configs -f fzf -o)
}}

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
        case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
    *.tar.gz|*.tgz) tar xzvf $f;;
    *.tar.xz|*.txz) tar xJvf $f;;
    *.zip) unzip $f;;
    *.rar) unrar x $f;;
    *.7z) 7z x $f;;
    esac
}}

cmd unarchive ${{
    case "$f" in
        *.zip) unzip "$f" ;;
        *.tar.gz) tar -xzvf "$f" ;;
        *.tar.bz2) tar -xjvf "$f" ;;
        *.tar) tar -xvf "$f" ;;
        *) echo "Unsupported format" ;;
    esac
}}
cmd zip %zip -r "$f" "$f"
cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz2 %tar cjvf "$f.tar.bz2" "$f"
